

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ConnPlotter.ConnPlotter &mdash; Nest Simulator Python API 2.10.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Nest Simulator Python API 2.10.0 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Nest Simulator Python API
          

          
          </a>

          
            
            
              <div class="version">
                2.10.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules/nest.html">nest package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Nest Simulator Python API</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>ConnPlotter.ConnPlotter</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ConnPlotter.ConnPlotter</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># ConnPlotter.py</span>
<span class="c1">#</span>
<span class="c1"># This file is part of NEST.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2004 The NEST Initiative</span>
<span class="c1">#</span>
<span class="c1"># NEST is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 2 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># NEST is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with NEST.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="c1"># ConnPlotter --- A Tool to Generate Connectivity Pattern Matrices</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ConnPlotter is a tool to create connectivity pattern tables.</span>

<span class="sd">For background on ConnPlotter, please see</span>

<span class="sd">  Eilen Nordlie and Hans Ekkehard Plesser.</span>
<span class="sd">  Connection Pattern Tables: A new way to visualize connectivity</span>
<span class="sd">  in neuronal network models.</span>
<span class="sd">  Frontiers in Neuroinformatics 3:39 (2010)</span>
<span class="sd">  doi: 10.3389/neuro.11.039.2009</span>

<span class="sd">Example:</span>
<span class="sd"># code creating population and connection lists</span>

<span class="sd">from ConnPlotter import ConnectionPattern, SynType</span>

<span class="sd"># Case A: All connections have the same &quot;synapse_model&quot;.</span>
<span class="sd">#</span>
<span class="sd"># Connections with weight &lt; 0 are classified as excitatory,</span>
<span class="sd">#                  weight &gt; 0 are classified as inhibitory.</span>
<span class="sd"># Each sender must make either excitatory or inhibitory connection,</span>
<span class="sd"># not both. When computing totals, excit/inhib connections are</span>
<span class="sd"># weighted with +-1.</span>
<span class="sd">pattern = ConnectionPattern(layerList, connList)</span>

<span class="sd"># Case B: All connections have the same &quot;synapse_model&quot;, but violate Dale&#39;s law</span>
<span class="sd">#</span>
<span class="sd"># Connections with weight &lt; 0 are classified as excitatory,</span>
<span class="sd">#                  weight &gt; 0 are classified as inhibitory.</span>
<span class="sd"># A single sender may have excitatory and inhibitory connections.</span>
<span class="sd"># When computing totals, excit/inhib connections are</span>
<span class="sd"># weighted with +-1.</span>
<span class="sd">pattern = ConnectionPattern(layerList, connList, </span>
<span class="sd">                            synTypes=(((SynType(&#39;exc&#39;,  1.0, &#39;b&#39;),</span>
<span class="sd">                                        SynType(&#39;inh&#39;, -1.0, &#39;r&#39;)),)))</span>

<span class="sd"># Case C: Synapse models are &quot;AMPA&quot;, &quot;NMDA&quot;, &quot;GABA_A&quot;, &quot;GABA_B&quot;.</span>
<span class="sd"># </span>
<span class="sd"># Connections are plotted by synapse model, with AMPA and NMDA</span>
<span class="sd"># on the top row, GABA_A and GABA_B in the bottom row when</span>
<span class="sd"># combining by layer. Senders must either have AMPA and NMDA or </span>
<span class="sd"># GABA_A and GABA_B synapses, but not both. When computing totals, </span>
<span class="sd"># AMPA and NMDA connections are weighted with +1, GABA_A and GABA_B</span>
<span class="sd"># with -1.</span>
<span class="sd">pattern = ConnectionPattern(layerList, connList)</span>

<span class="sd"># Case D: Explicit synapse types.</span>
<span class="sd">#</span>
<span class="sd"># If your network model uses other synapse types, or you want to use</span>
<span class="sd"># other weighting factors when computing totals, or you want different</span>
<span class="sd"># colormaps, you must specify synapse type information explicitly for</span>
<span class="sd"># ALL synase models in your network. For each synapse model, you create</span>
<span class="sd"># a </span>
<span class="sd">#</span>
<span class="sd">#        SynType(name, tweight, cmap)</span>
<span class="sd">#</span>
<span class="sd"># object, where &quot;name&quot; is the synapse model name, &quot;tweight&quot; the weight</span>
<span class="sd"># to be given to the type when computing totals (usually &gt;0 for excit, </span>
<span class="sd"># &lt;0 for inhib synapses), and &quot;cmap&quot; the &quot;colormap&quot;: if may be a</span>
<span class="sd"># matplotlib.colors.Colormap instance or any valid matplotlib color</span>
<span class="sd"># specification; in the latter case, as colormap will be generated </span>
<span class="sd"># ranging from white to the given color. </span>
<span class="sd"># Synapse types are passed as a tuple of tuples. Synapses in a tuple form</span>
<span class="sd"># a group. ConnPlotter assumes that a sender may make synapses with all</span>
<span class="sd"># types in a single group, but never synapses with types from different</span>
<span class="sd"># groups (If you group by transmitter, this simply reflects Dale&#39;s law).</span>
<span class="sd"># When connections are aggregated by layer, each group is printed on one </span>
<span class="sd"># row.</span>
<span class="sd">pattern = ConnectionPattern(layerList, connList, synTypes = \</span>
<span class="sd">    ((SynType(&#39;Asyn&#39;,  1.0, &#39;orange&#39;),</span>
<span class="sd">      SynType(&#39;Bsyn&#39;,  2.5, &#39;r&#39;),</span>
<span class="sd">      SynType(&#39;Csyn&#39;,  0.5, (1.0, 0.5, 0.0))),  # end first group</span>
<span class="sd">     (SynType(&#39;Dsyn&#39;, -1.5, matplotlib.pylab.cm.jet),</span>
<span class="sd">      SynType(&#39;Esyn&#39;, -3.2, &#39;0.95&#39;))))</span>
<span class="sd"># See documentation of class ConnectionPattern for more options.</span>

<span class="sd"># plotting the pattern</span>

<span class="sd"># show connection kernels for all sender-target pairs and all synapse models</span>
<span class="sd">pattern.plot()</span>

<span class="sd"># combine synapses of all types for each sender-target pair</span>
<span class="sd"># always used red-blue (inhib-excit) color scale</span>
<span class="sd">pattern.plot(aggrSyns=True)   </span>

<span class="sd"># for each pair of sender-target layer pair, show sums for each synapse type</span>
<span class="sd">pattern.plot(aggrGroups=True)</span>

<span class="sd"># As mode layer, but combine synapse types.</span>
<span class="sd"># always used red-blue (inhib-excit) color scale</span>
<span class="sd">pattern.plot(aggrSyns=True, aggrGroups=True)</span>

<span class="sd"># Show only synases of the selected type(s)</span>
<span class="sd">pattern.plot(mode=(&#39;AMPA&#39;,))</span>
<span class="sd">pattern.plot(mode=(&#39;AMPA&#39;, &#39;GABA_A&#39;))</span>

<span class="sd"># use same color scales for all patches</span>
<span class="sd">pattern.plot(globalColors=True)  </span>

<span class="sd"># manually specify limits for global color scale</span>
<span class="sd">pattern.plot(globalColors=True, colorLimits=[0, 2.5])  </span>

<span class="sd"># save to file(s)</span>
<span class="sd"># NB: do not write to PDF directly, this seems to cause artifacts</span>
<span class="sd">pattern.plot(file=&#39;net.png&#39;)  </span>
<span class="sd">pattern.plot(file=(&#39;net.eps&#39;,&#39;net.png&#39;))  </span>

<span class="sd"># You can adjust some properties of the figure by changing the</span>
<span class="sd"># default values in plotParams. </span>

<span class="sd"># Experimentally, you can dump the connection pattern into a LaTeX table</span>
<span class="sd">pattern.toLaTeX(&#39;pattern.tex&#39;, standalone=True)</span>

<span class="sd"># Figure layout can be modified by changing the global variable plotParams.</span>
<span class="sd"># Please see the documentation for class PlotParams for details.</span>

<span class="sd"># Changes 30 June 2010:</span>
<span class="sd"># - Singular layers (extent 0x0) are ignored as target layers.</span>
<span class="sd">#   The reason for this is so that single-generator &quot;layers&quot; can be</span>
<span class="sd">#   displayed as input.</span>
<span class="sd">#   Problems:</span>
<span class="sd">#   - singularity is not made clear visually</span>
<span class="sd">#   - This messes up the diagonal shading</span>
<span class="sd">#   - makes no sense to aggregate any longer</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#__version__ = &#39;$Revision: 546 $&#39;</span>
<span class="c1">#__date__    = &#39;$Date: 2010-06-30 16:36:33 +0200 (Wed, 30 Jun 2010) $&#39;</span>
<span class="n">__author__</span>  <span class="o">=</span> <span class="s1">&#39;Hans Ekkehard Plesser&#39;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ConnectionPattern&#39;</span><span class="p">,</span> <span class="s1">&#39;SynType&#39;</span><span class="p">,</span> <span class="s1">&#39;plotParams&#39;</span><span class="p">,</span> <span class="s1">&#39;PlotParams&#39;</span><span class="p">]</span>

<span class="c1"># ----------------------------------------------------------------------------</span>

<span class="c1"># To do:</span>
<span class="c1"># - proper testsuite</span>
<span class="c1"># - layers of different sizes not handled properly </span>
<span class="c1">#   (find biggest layer extent in each direction, then center;</span>
<span class="c1">#    may run into problems with population label placement)</span>
<span class="c1"># - clean up main</span>
<span class="c1"># - color bars</span>
<span class="c1"># - &quot;bad color&quot; should be configurable</span>
<span class="c1"># - fix hack for colormaps import</span>
<span class="c1"># - use generators where possible (eg kernels?)</span>

<span class="c1"># ----------------------------------------------------------------------------</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">colormaps</span> <span class="k">as</span> <span class="n">cm</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="kn">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="c1"># ----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="SynType"><a class="viewcode-back" href="../../modules/ConnPlotter.html#ConnPlotter.ConnPlotter.SynType">[docs]</a><span class="k">class</span> <span class="nc">SynType</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provide information about how synapse types should be rendered.</span>
<span class="sd">    </span>
<span class="sd">    A singly nested list of SynType objects can be passed to the</span>
<span class="sd">    ConnectionPattern constructor to specify layout and rendering info.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">relweight</span><span class="p">,</span> <span class="n">cmap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arguments:</span>
<span class="sd">        name         Name of synapse type (string, must be unique)</span>
<span class="sd">        relweight    Relative weight of synapse type when aggregating</span>
<span class="sd">                     across synapse types. Should be negative for inhibitory</span>
<span class="sd">                     connections.</span>
<span class="sd">        cmap         Either a matplotlib.colors.Colormap instance or a</span>
<span class="sd">                     color specification. In the latter case, the colormap</span>
<span class="sd">                     will be built from white to the color given. Thus,</span>
<span class="sd">                     the color should be fully saturated. Colormaps should</span>
<span class="sd">                     have &quot;set_bad(color=&#39;white&#39;)&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">relweight</span> <span class="o">=</span> <span class="n">name</span><span class="p">,</span> <span class="n">relweight</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Colormap</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span> <span class="o">=</span> <span class="n">cmap</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">make_colormap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span></div>

<span class="c1"># ----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="PlotParams"><a class="viewcode-back" href="../../modules/ConnPlotter.html#ConnPlotter.ConnPlotter.PlotParams">[docs]</a><span class="k">class</span> <span class="nc">PlotParams</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collects parameters governing plotting.</span>
<span class="sd">    Implemented using properties to ensure they are read-only.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PlotParams.Margins"><a class="viewcode-back" href="../../modules/ConnPlotter.html#ConnPlotter.ConnPlotter.PlotParams.Margins">[docs]</a>    <span class="k">class</span> <span class="nc">Margins</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Width of outer margins, in mm.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Set default values.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_left</span>  <span class="o">=</span> <span class="mf">15.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_right</span> <span class="o">=</span> <span class="mf">10.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top</span>   <span class="o">=</span> <span class="mf">10.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bottom</span><span class="o">=</span> <span class="mf">10.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_colbar</span><span class="o">=</span> <span class="mf">10.0</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span>
    
        <span class="nd">@left.setter</span>
        <span class="k">def</span> <span class="nf">left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span>
    
        <span class="nd">@right.setter</span>
        <span class="k">def</span> <span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top</span>
    
        <span class="nd">@top.setter</span>
        <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">bottom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bottom</span>
    
        <span class="nd">@bottom.setter</span>
        <span class="k">def</span> <span class="nf">bottom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bottom</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">colbar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colbar</span>
    
        <span class="nd">@colbar.setter</span>
        <span class="k">def</span> <span class="nf">colbar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colbar</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set default values&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_kern</span>       <span class="o">=</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_patch_size</span>   <span class="o">=</span> <span class="mf">20.0</span>  <span class="c1"># 20 mm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_bg</span>     <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;super&#39;</span><span class="p">:</span> <span class="s1">&#39;0.9&#39;</span><span class="p">,</span> <span class="s1">&#39;diag&#39;</span><span class="p">:</span> <span class="s1">&#39;0.8&#39;</span><span class="p">,</span> <span class="s1">&#39;sub&#39;</span><span class="p">:</span> <span class="s1">&#39;0.9&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_font</span>   <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="s1">&#39;large&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_orient</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sender&#39;</span><span class="p">:</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pop_font</span>     <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="s1">&#39;small&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pop_orient</span>   <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sender&#39;</span><span class="p">:</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_tick_font</span><span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="s1">&#39;x-small&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_title_font</span><span class="o">=</span><span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="s1">&#39;xx-small&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_ticks</span>    <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_tick_fmt</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_location</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cbwidth</span>      <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cbspace</span>      <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cbheight</span>     <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cboffset</span>     <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_layer</span>      <span class="o">=</span>  <span class="mi">25</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_pop</span>        <span class="o">=</span>  <span class="mi">50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_conn</span>       <span class="o">=</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">margins</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Margins</span><span class="p">()</span>

<div class="viewcode-block" id="PlotParams.reset"><a class="viewcode-back" href="../../modules/ConnPlotter.html#ConnPlotter.ConnPlotter.PlotParams.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset to default values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span></div>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_kern</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sample long kernel dimension at N_kernel points.&quot;&quot;&quot;</span>        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_kern</span>
    
    <span class="nd">@n_kern.setter</span>
    <span class="k">def</span> <span class="nf">n_kern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n_kern &gt; 0 required&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_kern</span> <span class="o">=</span> <span class="n">n</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">patch_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of the longest edge of the largest patch, in mm.&quot;&quot;&quot;</span>        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_size</span>
    
    <span class="nd">@patch_size.setter</span>
    <span class="k">def</span> <span class="nf">patch_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sz</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;patch_size &gt; 0 required&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_patch_size</span> <span class="o">=</span> <span class="n">sz</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">layer_bg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary of colors for layer background. </span>
<span class="sd">        Entries &quot;super&quot;, &quot;diag&quot;, &quot;sub&quot;. Each entry</span>
<span class="sd">        can be set to any valid color specification.</span>
<span class="sd">        If just a color is given, create dict by</span>
<span class="sd">        brightening/dimming.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer_bg</span>

    <span class="nd">@layer_bg.setter</span>
    <span class="k">def</span> <span class="nf">layer_bg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bg</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">bg</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">((</span><span class="s1">&#39;super&#39;</span><span class="p">,</span><span class="s1">&#39;diag&#39;</span><span class="p">,</span><span class="s1">&#39;sub&#39;</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Background dict must have keys &quot;super&quot;, &quot;diag&quot;, &quot;sub&quot;&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bgc</span> <span class="ow">in</span> <span class="n">bg</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">is_color_like</span><span class="p">(</span><span class="n">bgc</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Entries in background dict must be valid color specifications.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_layer_bg</span> <span class="o">=</span> <span class="n">bg</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">is_color_like</span><span class="p">(</span><span class="n">bg</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;layer_bg must be dict or valid color specification.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># is color like</span>
            <span class="n">rgb</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">colorConverter</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(</span><span class="n">bg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_layer_bg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;super&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.1</span> <span class="o">*</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">rgb</span><span class="p">],</span>
                              <span class="s1">&#39;diag&#39;</span> <span class="p">:</span> <span class="n">rgb</span><span class="p">,</span>
                              <span class="s1">&#39;sub&#39;</span>  <span class="p">:</span> <span class="p">[</span><span class="mf">0.9</span> <span class="o">*</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">rgb</span><span class="p">]}</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">layer_font</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Font to use for layer labels.</span>
<span class="sd">        Can be set to a matplotlib.font_manager.FontProperties instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer_font</span>

    <span class="nd">@layer_font.setter</span>
    <span class="k">def</span> <span class="nf">layer_font</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">font</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">font</span><span class="p">,</span> <span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;layer_font must be a matplotlib.font_manager.FontProperties instance.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_font</span> <span class="o">=</span> <span class="n">font</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">layer_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Orientation of layer labels.</span>
<span class="sd">        Dictionary with orientation of sender and target labels. Orientation</span>
<span class="sd">        is either &#39;horizontal&#39;, &#39;vertial&#39;, or a value in degrees.  When set </span>
<span class="sd">        to a single string or number, this value is used for both sender and</span>
<span class="sd">        target labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer_orient</span>

    <span class="nd">@layer_orientation.setter</span>
    <span class="k">def</span> <span class="nf">layer_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orient</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orient</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sender&#39;</span><span class="p">:</span> <span class="n">orient</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="n">orient</span><span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orient</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer_orient</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">orient</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Orientation ust be set to dict, string or number.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Orientation dictionary can only contain keys &quot;sender&quot; and &quot;target&quot;.&#39;</span><span class="p">)</span>
 
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_orient</span> <span class="o">=</span> <span class="n">tmp</span>
            
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pop_font</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Font to use for population labels.</span>
<span class="sd">        Can be set to a matplotlib.font_manager.FontProperties instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pop_font</span>
    
    <span class="nd">@pop_font.setter</span>
    <span class="k">def</span> <span class="nf">pop_font</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">font</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">font</span><span class="p">,</span> <span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pop_font must be a matplotlib.font_manager.FontProperties instance.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pop_font</span> <span class="o">=</span> <span class="n">font</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pop_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Orientation of population labels.</span>
<span class="sd">        Dictionary with orientation of sender and target labels. Orientation</span>
<span class="sd">        is either &#39;horizontal&#39;, &#39;vertial&#39;, or a value in degrees.  When set </span>
<span class="sd">        to a single string or number, this value is used for both sender and</span>
<span class="sd">        target labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pop_orient</span>

    <span class="nd">@pop_orientation.setter</span>
    <span class="k">def</span> <span class="nf">pop_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orient</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orient</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sender&#39;</span><span class="p">:</span> <span class="n">orient</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="n">orient</span><span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orient</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pop_orient</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">orient</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Orientation ust be set to dict, string or number.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Orientation dictionary can only contain keys &quot;sender&quot; and &quot;target&quot;.&#39;</span><span class="p">)</span>
 
        <span class="bp">self</span><span class="o">.</span><span class="n">_pop_orient</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">legend_tick_font</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        FontProperties for legend (colorbar) ticks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_tick_font</span>

    <span class="nd">@legend_tick_font.setter</span>
    <span class="k">def</span> <span class="nf">legend_tick_font</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">font</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">font</span><span class="p">,</span> <span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;legend_tick_font must be a matplotlib.font_manager.FontProperties instance.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_tick_font</span> <span class="o">=</span> <span class="n">font</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">legend_title_font</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        FontProperties for legend (colorbar) titles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_title_font</span>

    <span class="nd">@legend_title_font.setter</span>
    <span class="k">def</span> <span class="nf">legend_title_font</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">font</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">font</span><span class="p">,</span> <span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;legend_title_font must be a matplotlib.font_manager.FontProperties instance.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_title_font</span> <span class="o">=</span> <span class="n">font</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">legend_ticks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ordered list of values at which legend (colorbar) ticks shall be set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_ticks</span>

    <span class="nd">@legend_ticks.setter</span>
    <span class="k">def</span> <span class="nf">legend_ticks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ticks</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_ticks</span> <span class="o">=</span> <span class="n">ticks</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">legend_tick_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        C-style format string for legend (colorbar) tick marks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_tick_fmt</span>

    <span class="nd">@legend_tick_format.setter</span>
    <span class="k">def</span> <span class="nf">legend_tick_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tickfmt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_tick_fmt</span> <span class="o">=</span> <span class="n">tickfmt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">legend_location</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If set to &#39;top&#39;, place legend label above colorbar,</span>
<span class="sd">        if None, to the left.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_location</span>

    <span class="nd">@legend_location.setter</span>
    <span class="k">def</span> <span class="nf">legend_location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lgd_location</span> <span class="o">=</span> <span class="n">loc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cbwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Width of single colorbar, relative to figure width.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cbwidth</span>

    <span class="nd">@cbwidth.setter</span>
    <span class="k">def</span> <span class="nf">cbwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cbw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cbwidth</span> <span class="o">=</span> <span class="n">cbw</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cbheight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Height of colorbar, relative to margins.colbar</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cbheight</span>

    <span class="nd">@cbheight.setter</span>
    <span class="k">def</span> <span class="nf">cbheight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cbh</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cbheight</span> <span class="o">=</span> <span class="n">cbh</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cbspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Spacing between colorbars, relative to figure width.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cbspace</span>

    <span class="nd">@cbspace.setter</span>
    <span class="k">def</span> <span class="nf">cbspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cbs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cbspace</span> <span class="o">=</span> <span class="n">cbs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cboffset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Left offset of colorbar, relative to figure width.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cboffset</span>

    <span class="nd">@cboffset.setter</span>
    <span class="k">def</span> <span class="nf">cboffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cbo</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cboffset</span> <span class="o">=</span> <span class="n">cbo</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">z_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Z-value for layer label axes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_layer</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">z_pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Z-value for population label axes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_pop</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">z_conn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Z-value for connection kernel axes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_conn</span></div>
    
<span class="c1"># ----------------------------------------------------------------------------</span>

<span class="c1"># plotting settings, default values</span>
<span class="n">plotParams</span> <span class="o">=</span> <span class="n">PlotParams</span><span class="p">()</span>
        
<span class="c1"># ----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="ConnectionPattern"><a class="viewcode-back" href="../../modules/ConnPlotter.html#ConnPlotter.ConnPlotter.ConnectionPattern">[docs]</a><span class="k">class</span> <span class="nc">ConnectionPattern</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connection pattern representation for plotting.</span>

<span class="sd">    When a ConnectionPattern is instantiated, all connection kernels</span>
<span class="sd">    are pre-computed. They can later be plotted in various forms by</span>
<span class="sd">    calling the plot() method.</span>

<span class="sd">    The constructor requires layer and connection lists:</span>

<span class="sd">       ConnectionPattern(layerList, connList, synTypes, **kwargs)</span>

<span class="sd">    The layerList is used to:</span>
<span class="sd">       - determine the size of patches</span>
<span class="sd">       - determine the block structure</span>

<span class="sd">    All other information is taken from the connList. Information</span>
<span class="sd">    about synapses is inferred from the connList.</span>

<span class="sd">    The following keyword arguments can also be given:</span>

<span class="sd">    poporder :  Population order. A dictionary mapping population names </span>
<span class="sd">                to numbers; populations will be sorted in diagram in order </span>
<span class="sd">                of increasing numbers. Otherwise, they are sorted </span>
<span class="sd">                alphabetically.</span>

<span class="sd">    intensity:  &#39;wp&#39;  -  use weight * probability (default)</span>
<span class="sd">                &#39;p&#39;   -  use probability alone </span>
<span class="sd">                &#39;tcd&#39; -  use total charge deposited * probability</span>
<span class="sd">                         requires mList and Vmem; per v 0.7 only supported</span>
<span class="sd">                         for ht_neuron.</span>

<span class="sd">    mList    :  model list; required for &#39;tcd&#39;</span>
<span class="sd">    Vmem     :  membrane potential; required for &#39;tcd&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    
    <span class="k">class</span> <span class="nc">_LayerProps</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information about layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">extent</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            name  : name of layer</span>
<span class="sd">            extent: spatial extent of the layer</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ext</span>  <span class="o">=</span> <span class="n">extent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">singular</span> <span class="o">=</span> <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    
    <span class="k">class</span> <span class="nc">_SynProps</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information on how to plot patches for a synapse type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">tweight</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            row, col: Position of synapse in grid of synapse patches, begins at 0,0    </span>
<span class="sd">            tweight : weight to apply when adding kernels for different synapses</span>
<span class="sd">            cmap    : colormap for synapse type (matplotlib.colors.Colormap instance)</span>
<span class="sd">            idx     : linear index, used to order colorbars in figure</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tw</span>        <span class="o">=</span> <span class="n">tweight</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span>      <span class="o">=</span> <span class="n">cmap</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span>     <span class="o">=</span> <span class="n">idx</span>

    <span class="c1"># --------------------------------------------------------------------</span>

    <span class="k">class</span> <span class="nc">_PlotKern</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Representing object ready for plotting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sl</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">syn</span><span class="p">,</span> <span class="n">kern</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            sl  : sender layer</span>
<span class="sd">            sn  : sender neuron/population</span>
<span class="sd">            tl  : target layer</span>
<span class="sd">            tn  : target neuron/population</span>
<span class="sd">            syn : synapse model</span>
<span class="sd">            kern: kernel values (numpy masked array)</span>
<span class="sd">            All arguments but kern are strings.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sl</span>   <span class="o">=</span> <span class="n">sl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sn</span>   <span class="o">=</span> <span class="n">sn</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tl</span>   <span class="o">=</span> <span class="n">tl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tn</span>   <span class="o">=</span> <span class="n">tn</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">syn</span>  <span class="o">=</span> <span class="n">syn</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kern</span> <span class="o">=</span> <span class="n">kern</span>
            
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="k">class</span> <span class="nc">_Connection</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conninfo</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">synapses</span><span class="p">,</span> <span class="n">intensity</span><span class="p">,</span> <span class="n">tcd</span><span class="p">,</span> <span class="n">Vmem</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Arguments:</span>
<span class="sd">            conninfo: list of connection info entries: (sender, target, conn_dict)</span>
<span class="sd">            layers  : list of _LayerProps objects</span>
<span class="sd">            synapses: list of _SynProps objects</span>
<span class="sd">            intensity: &#39;wp&#39;, &#39;p&#39;, &#39;tcd&#39;</span>
<span class="sd">            tcd      : tcd object</span>
<span class="sd">            Vmem     : reference membrane potential for tcd calculations</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_intensity</span> <span class="o">=</span> <span class="n">intensity</span>

            <span class="c1"># get source and target layer</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slayer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tlayer</span> <span class="o">=</span> <span class="n">conninfo</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>  
            <span class="n">lnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">slayer</span> <span class="ow">in</span> <span class="n">lnames</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown source layer &quot;</span><span class="si">%s</span><span class="s1">&quot;.&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">slayer</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tlayer</span> <span class="ow">in</span> <span class="n">lnames</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown target layer &quot;</span><span class="si">%s</span><span class="s1">&quot;.&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tlayer</span><span class="p">)</span>

            <span class="c1"># if target layer is singular (extent==(0,0)) we do not create a full object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">singular</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tlayer</span> <span class="ow">and</span> <span class="n">l</span><span class="o">.</span><span class="n">singular</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">singular</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">return</span>

            <span class="c1"># see if we connect to/from specific neuron types</span>
            <span class="n">cdict</span> <span class="o">=</span> <span class="n">conninfo</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">if</span> <span class="s1">&#39;sources&#39;</span> <span class="ow">in</span> <span class="n">cdict</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cdict</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">,</span> <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">snrn</span> <span class="o">=</span> <span class="n">cdict</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">][</span><span class="s1">&#39;model&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can only handle sources in form {&quot;model&quot;: ...}&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">snrn</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">if</span> <span class="s1">&#39;targets&#39;</span> <span class="ow">in</span> <span class="n">cdict</span><span class="p">:</span> 
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cdict</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">,</span> <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tnrn</span> <span class="o">=</span> <span class="n">cdict</span><span class="p">[</span><span class="s1">&#39;targets&#39;</span><span class="p">][</span><span class="s1">&#39;model&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can only handle targets in form {&quot;model&quot;: ...}&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tnrn</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c1"># now get (mean) weight, we need this if we classify</span>
            <span class="c1"># connections by sign of weight only</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mean_wght</span> <span class="o">=</span> <span class="n">_weighteval</span><span class="p">(</span><span class="n">cdict</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No or corrupt weight information.&#39;</span><span class="p">)</span>

            <span class="c1"># synapse model</span>
            <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">synapses</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;exc&#39;</span><span class="p">,</span> <span class="s1">&#39;inh&#39;</span><span class="p">]:</span>
                <span class="c1"># implicit synapse type, we ignore value of</span>
                <span class="c1"># &#39;synapse_model&#39;, it is for use by NEST only</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mean_wght</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">synmodel</span> <span class="o">=</span> <span class="s1">&#39;exc&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">synmodel</span> <span class="o">=</span> <span class="s1">&#39;inh&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">synmodel</span> <span class="o">=</span> <span class="n">cdict</span><span class="p">[</span><span class="s1">&#39;synapse_model&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">synmodel</span> <span class="ow">in</span> <span class="n">synapses</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown synapse model &quot;</span><span class="si">%s</span><span class="s1">&quot;.&#39;</span> 
                                        <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">synmodel</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Explicit synapse model info required.&#39;</span><span class="p">)</span>

            <span class="c1"># store information about connection</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">cdict</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kern</span> <span class="o">=</span> <span class="n">cdict</span><span class="p">[</span><span class="s1">&#39;kernel&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wght</span> <span class="o">=</span> <span class="n">cdict</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span>
                <span class="c1"># next line presumes only one layer name will match</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_textent</span> <span class="o">=</span> <span class="p">[</span><span class="n">tl</span><span class="o">.</span><span class="n">ext</span> <span class="k">for</span> <span class="n">tl</span> <span class="ow">in</span> <span class="n">layers</span> 
                                 <span class="k">if</span> <span class="n">tl</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">tlayer</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">intensity</span> <span class="o">==</span> <span class="s1">&#39;tcd&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tcd</span> <span class="o">=</span> <span class="n">tcd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synmodel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tnrn</span><span class="p">,</span> <span class="n">Vmem</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tcd</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Corrupt connection dictionary&#39;</span><span class="p">)</span>

            <span class="c1"># prepare for lazy evaluation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kernel</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># --------------------------------------------------------------------</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">keyval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return key and _Connection as tuple.</span>
<span class="sd">            Useful to create dictionary via list comprehension.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">singular</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">slayer</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">snrn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tlayer</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tnrn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">synmodel</span><span class="p">),</span> 
                        <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># --------------------------------------------------------------------</span>
        
        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">kernval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Kernel value, as masked array.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kernel</span> <span class="o">=</span> <span class="n">_evalkernel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kern</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mean_wght</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_textent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intensity</span><span class="p">,</span> 
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_tcd</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel</span>

        <span class="c1"># --------------------------------------------------------------------</span>
        
        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Dictionary describing the mask.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>

        <span class="c1"># --------------------------------------------------------------------</span>
        
        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Dictionary describing the kernel.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kern</span>

        <span class="c1"># --------------------------------------------------------------------</span>
        
        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Dictionary describing weight distribution.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wght</span>

        <span class="c1"># --------------------------------------------------------------------</span>

        <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sl</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tl</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">syn</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return True if all non-None arguments match.</span>
<span class="sd">            Arguments:</span>
<span class="sd">            sl : sender layer</span>
<span class="sd">            sn : sender neuron type</span>
<span class="sd">            tl : target layer</span>
<span class="sd">            tn : target neuron type</span>
<span class="sd">            syn: synapse type</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">return</span>  <span class="p">(</span><span class="n">sl</span>  <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">sl</span>  <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">slayer</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="n">sn</span>  <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">sn</span>  <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">snrn</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="n">tl</span>  <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">tl</span>  <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tlayer</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="n">tn</span>  <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">tn</span>  <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tnrn</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="n">syn</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">syn</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">synmodel</span><span class="p">)</span> 

    <span class="c1"># ----------------------------------------------------------------------------</span>

    <span class="k">class</span> <span class="nc">_Patch</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Represents a patch, i.e., an axes that will actually contain an</span>
<span class="sd">        imshow graphic of a connection kernel.</span>
<span class="sd">        The patch object contains the physical coordinates of the patch,</span>
<span class="sd">        as well as a reference to the actual Axes object once it is created.</span>
<span class="sd">        Also contains strings to be used as sender/target labels.</span>

<span class="sd">        Everything is based on a coordinate system looking from the top left</span>
<span class="sd">        corner down.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># --------------------------------------------------------------------</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> 
                     <span class="n">slabel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tlabel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Arguments:</span>
<span class="sd">            left, top     : Location of top-left corner</span>
<span class="sd">            row, col      : row, column location in parent block</span>
<span class="sd">            width, height : Width and height of patch</span>
<span class="sd">            slabel, tlabel: Values for sender/target label</span>
<span class="sd">            parent        : _Block to which _Patch/_Block belongs</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slbl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tlbl</span> <span class="o">=</span> <span class="n">slabel</span><span class="p">,</span> <span class="n">tlabel</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">parent</span>

        <span class="c1"># --------------------------------------------------------------------</span>

        <span class="k">def</span> <span class="nf">_update_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_lr</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Update patch size by inspecting all children.&quot;&quot;&quot;</span> 
            <span class="k">if</span> <span class="n">new_lr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:</span> 
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;new_lr[0] = </span><span class="si">%f</span><span class="s2"> &lt; l = </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">new_lr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">new_lr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">:</span> 
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;new_lr[1] = </span><span class="si">%f</span><span class="s2"> &lt; t = </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">new_lr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">new_lr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">new_lr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_update_size</span><span class="p">(</span><span class="n">new_lr</span><span class="p">)</span>

        <span class="c1"># --------------------------------------------------------------------</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">tl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
            <span class="sd">&quot;&quot;&quot;Top left corner of the patch.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>

        <span class="c1"># --------------------------------------------------------------------</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">lr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
            <span class="sd">&quot;&quot;&quot;Lower right corner of the patch.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>

        <span class="c1"># --------------------------------------------------------------------</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">l_patches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Left edge of leftmost _Patch in _Block.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ConnectionPattern</span><span class="o">.</span><span class="n">_Block</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">l_patches</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span>

        <span class="c1"># --------------------------------------------------------------------</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">t_patches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Top edge of topmost _Patch in _Block.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ConnectionPattern</span><span class="o">.</span><span class="n">_Block</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">t_patches</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span>

        <span class="c1"># --------------------------------------------------------------------</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">r_patches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Right edge of rightmost _Patch in _Block.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ConnectionPattern</span><span class="o">.</span><span class="n">_Block</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">r_patches</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>

        <span class="c1"># --------------------------------------------------------------------</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">b_patches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Bottom edge of lowest _Patch in _Block.&quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ConnectionPattern</span><span class="o">.</span><span class="n">_Block</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">b_patches</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span>

        <span class="c1"># --------------------------------------------------------------------</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">location</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;super&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;diag&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;sub&#39;</span>

    <span class="c1"># ----------------------------------------------------------------------------</span>

    <span class="k">class</span> <span class="nc">_Block</span><span class="p">(</span><span class="n">_Patch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Represents a block of patches. </span>

<span class="sd">        A block is initialized with its top left corner and is then built</span>
<span class="sd">        row-wise downward and column-wise to the right. Rows are added by</span>

<span class="sd">        block.newRow(2.0, 1.5)</span>

<span class="sd">        where 2.0 is the space between rows, 1.5 the space between the</span>
<span class="sd">        first row. Elements are added to a row by</span>

<span class="sd">        el = block.newElement(1.0, 0.6, &#39;s&#39;, &#39;t&#39;)</span>
<span class="sd">        el = block.newElement(1.0, 0.6, &#39;s&#39;, &#39;t&#39;, size=[2.0, 3.0])</span>

<span class="sd">        The first example adds a new _Block to the row. 1.0 is the space between</span>
<span class="sd">        blocks, 0.6 the space before the first block in a row. &#39;s&#39; and &#39;t&#39; are</span>
<span class="sd">        stored as slbl and tlbl (optional). If size is given, a _Patch with</span>
<span class="sd">        the given size is created. _Patch is atomic. newElement() returns the</span>
<span class="sd">        _Block or _Patch created.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ------------------------------------------------------------------------</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">slabel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tlabel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="n">ConnectionPattern</span><span class="o">.</span><span class="n">_Patch</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slabel</span><span class="p">,</span> <span class="n">tlabel</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_row_top</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># top of current row</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># ------------------------------------------------------------------------</span>

        <span class="k">def</span> <span class="nf">newRow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dynew</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Open new row of elements.</span>
<span class="sd">            Arguments:</span>
<span class="sd">            dy   : vertical skip before new row</span>
<span class="sd">            dynew: vertical skip if new row is first row</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="c1"># top of row is bottom of block so far + dy</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_row_top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># place relative to top edge of parent</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_row_top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dynew</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            
        <span class="c1"># ------------------------------------------------------------------------</span>

        <span class="k">def</span> <span class="nf">newElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dxnew</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">slabel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tlabel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                       <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Append new element to last row. </span>
<span class="sd">            Creates _Block instance if size is not given, otherwise _Patch.</span>

<span class="sd">            Arguments:</span>
<span class="sd">            dx    : horizontal skip before new element</span>
<span class="sd">            dxnew : horizontal skip if new element is first</span>
<span class="sd">            slabel: sender label (on y-axis)</span>
<span class="sd">            tlabel: target label (on x-axis)</span>
<span class="sd">            size  : size of _Patch to create</span>

<span class="sd">            Returns:</span>
<span class="sd">            Created _Block or _Patch.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># left edge is right edge of block so far + dx</span>
                <span class="n">col_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># place relative to left edge of parent</span>
                <span class="n">col_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dxnew</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">elem</span> <span class="o">=</span> <span class="n">ConnectionPattern</span><span class="o">.</span><span class="n">_Patch</span><span class="p">(</span><span class="n">col_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col</span><span class="p">,</span>
                                                <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">slabel</span><span class="p">,</span> <span class="n">tlabel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">elem</span> <span class="o">=</span> <span class="n">ConnectionPattern</span><span class="o">.</span><span class="n">_Block</span><span class="p">(</span><span class="n">col_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col</span><span class="p">,</span>
                                                <span class="n">slabel</span><span class="p">,</span> <span class="n">tlabel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_size</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">lr</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">elem</span>

        <span class="c1"># ------------------------------------------------------------------------</span>

        <span class="k">def</span> <span class="nf">addMargin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rmarg</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">bmarg</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Extend block by margin to right and bottom.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">rmarg</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rmarg must not be negative!&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bmarg</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bmarg must not be negative!&#39;</span><span class="p">)</span>

            <span class="n">lr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_size</span><span class="p">((</span><span class="n">lr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">rmarg</span><span class="p">,</span> <span class="n">lr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bmarg</span><span class="p">))</span>

    <span class="c1"># ----------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_prepareAxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">showLegend</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare information for all axes, but do not create the actual axes yet.</span>
<span class="sd">        mode: one of &#39;detailed&#39;, &#39;by layer&#39;, &#39;totals&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># parameters for figure, all quantities are in mm</span>
        <span class="n">patchmax</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">patch_size</span> <span class="c1"># length of largest patch patch dimension</span>

        <span class="c1"># actual parameters scaled from default patchmax = 20mm</span>
        <span class="n">lmargin</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">margins</span><span class="o">.</span><span class="n">left</span>
        <span class="n">tmargin</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">margins</span><span class="o">.</span><span class="n">top</span>
        <span class="n">rmargin</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">margins</span><span class="o">.</span><span class="n">right</span>
        <span class="n">bmargin</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">margins</span><span class="o">.</span><span class="n">bottom</span>
        <span class="n">cbmargin</span><span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">margins</span><span class="o">.</span><span class="n">colbar</span>
        
        <span class="n">blksep</span>  <span class="o">=</span>  <span class="mf">3.</span><span class="o">/</span><span class="mf">20.</span> <span class="o">*</span> <span class="n">patchmax</span>  <span class="c1"># distance between blocks</span>
        <span class="n">popsep</span>  <span class="o">=</span>  <span class="mf">2.</span><span class="o">/</span><span class="mf">20.</span> <span class="o">*</span> <span class="n">patchmax</span>  <span class="c1"># distance between populations</span>
        <span class="n">synsep</span>  <span class="o">=</span>  <span class="mf">0.5</span><span class="o">/</span><span class="mf">20.</span><span class="o">*</span> <span class="n">patchmax</span>  <span class="c1"># distance between synapse types</span>

        <span class="c1"># find maximal extents of individual patches, horizontal and vertical</span>
        <span class="n">maxext</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">_flattened</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">ext</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">]))</span>
        
        <span class="n">patchscale</span> <span class="o">=</span> <span class="n">patchmax</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxext</span><span class="p">)</span>  <span class="c1"># determines patch size</span>

        <span class="c1"># obtain number of synaptic patches per population pair</span>
        <span class="c1"># maximum column across all synapse types, same for rows</span>
        <span class="n">nsyncols</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">c</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nsynrows</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">r</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># dictionary mapping into patch-axes, to they can be found later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_patchTable</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># set to store all created patches to avoid multiple</span>
        <span class="c1"># creation of patches at same location</span>
        <span class="n">axset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># create entire setup, top-down</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Block</span><span class="p">(</span><span class="n">lmargin</span><span class="p">,</span> <span class="n">tmargin</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">:</span>

            <span class="c1"># get sorted list of populations for sender layer</span>
            <span class="n">spops</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pops</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">sl</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                           <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pn</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poporder</span><span class="p">[</span><span class="n">pn</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">newRow</span><span class="p">(</span><span class="n">blksep</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">tl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">:</span>

                <span class="c1"># ignore singular target layers</span>
                <span class="k">if</span> <span class="n">tl</span><span class="o">.</span><span class="n">singular</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># get sorted list of populations for target layer</span>
                <span class="n">tpops</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pops</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">tl</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                               <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pn</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poporder</span><span class="p">[</span><span class="n">pn</span><span class="p">])</span>

                <span class="c1"># compute size for patches</span>
                <span class="n">patchsize</span> <span class="o">=</span> <span class="n">patchscale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tl</span><span class="o">.</span><span class="n">ext</span><span class="p">)</span>

                <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">newElement</span><span class="p">(</span><span class="n">blksep</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">sl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tl</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;totals&#39;</span><span class="p">:</span>
                    <span class="c1"># single patch</span>
                    <span class="n">block</span><span class="o">.</span><span class="n">newRow</span><span class="p">(</span><span class="n">popsep</span><span class="p">,</span> <span class="n">popsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">newElement</span><span class="p">(</span><span class="n">popsep</span><span class="p">,</span> <span class="n">popsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">patchsize</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_patchTable</span><span class="p">[(</span><span class="n">sl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">tl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p</span>

                <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;layer&#39;</span><span class="p">:</span>
                    <span class="c1"># We loop over all rows and columns in the synapse patch grid.</span>
                    <span class="c1"># For each (r,c), we find the pertaining synapse name by reverse</span>
                    <span class="c1"># lookup in the _synAttr dictionary. This is inefficient, but</span>
                    <span class="c1"># should not be too costly overall. But we must create the</span>
                    <span class="c1"># patches in the order they are placed.</span>
                    <span class="c1"># NB: We must create also those block.newElement() that are not</span>
                    <span class="c1">#     registered later, since block would otherwise not skip </span>
                    <span class="c1">#     over the unused location.</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsynrows</span><span class="p">):</span>
                        <span class="n">block</span><span class="o">.</span><span class="n">newRow</span><span class="p">(</span><span class="n">synsep</span><span class="p">,</span> <span class="n">popsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsyncols</span><span class="p">):</span>
                            <span class="n">p</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">newElement</span><span class="p">(</span><span class="n">synsep</span><span class="p">,</span> <span class="n">popsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">patchsize</span><span class="p">)</span>
                            <span class="n">smod</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">r</span> <span class="o">==</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">c</span> <span class="o">==</span> <span class="n">c</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">smod</span><span class="p">:</span>
                                <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">smod</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_patchTable</span><span class="p">[(</span><span class="n">sl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="n">tl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="n">smod</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">p</span>

                <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;population&#39;</span><span class="p">:</span>
                    <span class="c1"># one patch per population pair</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spops</span><span class="p">:</span>
                        <span class="n">block</span><span class="o">.</span><span class="n">newRow</span><span class="p">(</span><span class="n">popsep</span><span class="p">,</span> <span class="n">popsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">tpops</span><span class="p">:</span>
                            <span class="n">pblk</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">newElement</span><span class="p">(</span><span class="n">popsep</span><span class="p">,</span> <span class="n">popsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span>
                            <span class="n">pblk</span><span class="o">.</span><span class="n">newRow</span><span class="p">(</span><span class="n">synsep</span><span class="p">,</span> <span class="n">synsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_patchTable</span><span class="p">[(</span><span class="n">sl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="n">tl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">tp</span><span class="p">,</span><span class="bp">None</span><span class="p">)]</span> <span class="o">=</span> \
                                <span class="n">pblk</span><span class="o">.</span><span class="n">newElement</span><span class="p">(</span><span class="n">synsep</span><span class="p">,</span> <span class="n">blksep</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">patchsize</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># detailed presentation of all pops</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spops</span><span class="p">:</span>
                        <span class="n">block</span><span class="o">.</span><span class="n">newRow</span><span class="p">(</span><span class="n">popsep</span><span class="p">,</span> <span class="n">popsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">tpops</span><span class="p">:</span>
                            <span class="n">pblk</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">newElement</span><span class="p">(</span><span class="n">popsep</span><span class="p">,</span> <span class="n">popsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span>
                            <span class="n">pblk</span><span class="o">.</span><span class="n">newRow</span><span class="p">(</span><span class="n">synsep</span><span class="p">,</span> <span class="n">synsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

                            <span class="c1"># Find all connections with matching properties</span>
                            <span class="c1"># all information we need here is synapse model.</span>
                            <span class="c1"># We store this in a dictionary mapping synapse</span>
                            <span class="c1"># patch column to synapse model, for use below.</span>
                            <span class="n">syns</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">synmodel</span><span class="p">]</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">synmodel</span><span class="p">)</span>
                                         <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                                         <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">sl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">tl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tp</span><span class="p">)])</span>
                        
                            <span class="c1"># create all synapse patches</span>
                            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsyncols</span><span class="p">):</span>

                                <span class="c1"># Do not duplicate existing axes.</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="n">tl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">tp</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="n">axset</span><span class="p">:</span>
                                    <span class="k">continue</span>  

                                <span class="c1"># Create patch. We must create also such patches</span>
                                <span class="c1"># that do not have synapses, since spacing would</span>
                                <span class="c1"># go wrong otherwise.</span>
                                <span class="n">p</span> <span class="o">=</span> <span class="n">pblk</span><span class="o">.</span><span class="n">newElement</span><span class="p">(</span><span class="n">synsep</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">patchsize</span><span class="p">)</span>

                                <span class="c1"># if patch represents existing synapse, register</span>
                                <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">syns</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_patchTable</span><span class="p">[(</span><span class="n">sl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="n">tl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">tp</span><span class="p">,</span><span class="n">syns</span><span class="p">[</span><span class="n">n</span><span class="p">])]</span> <span class="o">=</span> <span class="n">p</span>

                <span class="n">block</span><span class="o">.</span><span class="n">addMargin</span><span class="p">(</span><span class="n">popsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">popsep</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">addMargin</span><span class="p">(</span><span class="n">rmargin</span><span class="p">,</span> <span class="n">bmargin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">showLegend</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">addMargin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cbmargin</span><span class="p">)</span>  <span class="c1"># add color bar at bottom</span>
            <span class="n">figwidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">lr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">rmargin</span> <span class="c1"># keep right marg out of calc</span>

            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;totals&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;population&#39;</span><span class="p">:</span>

                <span class="c1"># single patch at right edge, 20% of figure</span>
                <span class="k">if</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cbwidth</span><span class="p">:</span>
                    <span class="n">lwidth</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cbwidth</span> <span class="o">*</span> <span class="n">figwidth</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lwidth</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">figwidth</span>
                    <span class="k">if</span> <span class="n">lwidth</span> <span class="o">&gt;</span> <span class="mf">100.0</span><span class="p">:</span>   <span class="c1"># colorbar should not be wider than 10cm</span>
                        <span class="n">lwidth</span> <span class="o">=</span> <span class="mf">100.0</span>
                <span class="n">lheight</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cbheight</span><span class="o">*</span><span class="n">cbmargin</span> <span class="k">if</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cbheight</span> <span class="k">else</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">cbmargin</span>

                <span class="k">if</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">legend_location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">cblift</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="o">*</span> <span class="n">cbmargin</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cblift</span> <span class="o">=</span> <span class="mf">0.7</span> <span class="o">*</span> <span class="n">cbmargin</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_cbPatches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Patch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">lr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span> <span class="n">cblift</span><span class="p">,</span>
                                              <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> 
                                              <span class="n">lwidth</span><span class="p">,</span>
                                              <span class="n">lheight</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># one patch per synapse type, 20% of figure or less</span>

                <span class="c1"># we need to get the synapse names in ascending order of synapse indices</span>
                <span class="n">snames</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> 
                          <span class="nb">sorted</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span>
                                 <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                          <span class="p">]</span>
                <span class="n">snum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">snames</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cbwidth</span><span class="p">:</span>
                    <span class="n">lwidth</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cbwidth</span> <span class="o">*</span> <span class="n">figwidth</span>
                    <span class="k">if</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cbspace</span><span class="p">:</span>
                        <span class="n">lstep</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cbspace</span> <span class="o">*</span> <span class="n">figwidth</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lstep</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">lwidth</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">snum</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                        <span class="n">lwidth</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="o">*</span> <span class="n">figwidth</span>
                        <span class="n">lstep</span>  <span class="o">=</span> <span class="mf">0.1</span>  <span class="o">*</span> <span class="n">figwidth</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lwidth</span> <span class="o">=</span> <span class="n">figwidth</span> <span class="o">/</span> <span class="p">(</span><span class="n">snum</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
                        <span class="n">lstep</span> <span class="o">=</span> <span class="p">(</span><span class="n">figwidth</span> <span class="o">-</span> <span class="n">snum</span><span class="o">*</span><span class="n">lwidth</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">snum</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">lwidth</span> <span class="o">&gt;</span> <span class="mf">100.0</span><span class="p">:</span>   <span class="c1"># colorbar should not be wider than 10cm</span>
                        <span class="n">lwidth</span> <span class="o">=</span> <span class="mf">100.0</span>
                        <span class="n">lstep</span> <span class="o">=</span> <span class="mf">30.0</span>
                <span class="n">lheight</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cbheight</span><span class="o">*</span><span class="n">cbmargin</span> <span class="k">if</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cbheight</span> <span class="k">else</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">cbmargin</span>

                <span class="k">if</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cboffset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">cboffset</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">lstep</span>
                    
                <span class="k">if</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">legend_location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">cblift</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="o">*</span> <span class="n">cbmargin</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cblift</span> <span class="o">=</span> <span class="mf">0.7</span> <span class="o">*</span> <span class="n">cbmargin</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_cbPatches</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">snum</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cbPatches</span><span class="p">[</span><span class="n">snames</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">_Patch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">lstep</span> <span class="o">+</span> <span class="n">lwidth</span><span class="p">),</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">lr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cblift</span><span class="p">,</span>
                                    <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span>
                                    <span class="n">lwidth</span><span class="p">,</span>
                                    <span class="n">lheight</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_scaledBox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scaled axes rectangle for patch, reverses y-direction.&quot;&quot;&quot;</span>
        <span class="n">xsc</span><span class="p">,</span> <span class="n">ysc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">lr</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_figscale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">l</span><span class="o">/</span><span class="n">xsc</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">t</span><span class="o">+</span><span class="n">p</span><span class="o">.</span><span class="n">h</span><span class="p">)</span><span class="o">/</span><span class="n">ysc</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">w</span><span class="o">/</span><span class="n">xsc</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">h</span><span class="o">/</span><span class="n">ysc</span><span class="p">])</span>

    <span class="c1"># ----------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_scaledBoxNR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scaled axes rectangle for patch, does not reverse y-direction.&quot;&quot;&quot;</span>
        <span class="n">xsc</span><span class="p">,</span> <span class="n">ysc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">lr</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_figscale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">l</span><span class="o">/</span><span class="n">xsc</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">t</span><span class="o">/</span><span class="n">ysc</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">w</span><span class="o">/</span><span class="n">xsc</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">h</span><span class="o">/</span><span class="n">ysc</span><span class="p">])</span>

    <span class="c1"># ----------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_configSynapses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cList</span><span class="p">,</span> <span class="n">synTypes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configure synapse information based on connections and user info.&quot;&quot;&quot;</span>

        <span class="c1"># compile information on synapse types and weights</span>
        <span class="n">synnames</span>   <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;synapse_model&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cList</span><span class="p">)</span>
        <span class="n">synweights</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_weighteval</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weights&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cList</span><span class="p">)</span>

        <span class="c1"># set up synTypes for all pre-defined cases</span>
        <span class="k">if</span> <span class="n">synTypes</span><span class="p">:</span>
            <span class="c1"># check if there is info for all synapse types</span>
            <span class="n">stnames</span> <span class="o">=</span> <span class="n">_flattened</span><span class="p">([[</span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">synTypes</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stnames</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">stnames</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Names of synapse types in synTypes must be unique!&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">synnames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">synnames</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">stnames</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;synTypes must provide information about all synapse types.&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">synnames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># only one synapse type used</span>
            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">synweights</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># all weights positive</span>
                <span class="n">synTypes</span> <span class="o">=</span> <span class="p">((</span><span class="n">SynType</span><span class="p">(</span><span class="s1">&#39;exc&#39;</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">),),)</span>
            <span class="k">elif</span> <span class="nb">max</span><span class="p">(</span><span class="n">synweights</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># all weights negative</span>
                <span class="n">synTypes</span> <span class="o">=</span> <span class="p">((</span><span class="n">SynType</span><span class="p">(</span><span class="s1">&#39;inh&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">),),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># positive and negative weights, assume Dale holds</span>
                <span class="n">synTypes</span> <span class="o">=</span> <span class="p">((</span><span class="n">SynType</span><span class="p">(</span><span class="s1">&#39;exc&#39;</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">),),</span>
                            <span class="p">(</span><span class="n">SynType</span><span class="p">(</span><span class="s1">&#39;inh&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span> <span class="p">),))</span>

        <span class="k">elif</span> <span class="n">synnames</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;AMPA&#39;</span><span class="p">,</span> <span class="s1">&#39;GABA_A&#39;</span><span class="p">]):</span>
                <span class="c1"># only AMPA and GABA_A</span>
                <span class="n">synTypes</span> <span class="o">=</span> <span class="p">((</span><span class="n">SynType</span><span class="p">(</span><span class="s1">&#39;AMPA&#39;</span>  <span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">),),</span>
                            <span class="p">(</span><span class="n">SynType</span><span class="p">(</span><span class="s1">&#39;GABA_A&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span> <span class="p">),))</span>

        <span class="k">elif</span> <span class="n">synnames</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;AMPA&#39;</span><span class="p">,</span><span class="s1">&#39;NMDA&#39;</span><span class="p">,</span><span class="s1">&#39;GABA_A&#39;</span><span class="p">,</span><span class="s1">&#39;GABA_B&#39;</span><span class="p">])):</span>
            <span class="n">synTypes</span> <span class="o">=</span> <span class="p">((</span><span class="n">SynType</span><span class="p">(</span><span class="s1">&#39;AMPA&#39;</span>  <span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span>     <span class="p">),</span>
                         <span class="n">SynType</span><span class="p">(</span><span class="s1">&#39;NMDA&#39;</span>  <span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span>  <span class="p">),),</span>
                        <span class="p">(</span><span class="n">SynType</span><span class="p">(</span><span class="s1">&#39;GABA_A&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span>    <span class="p">),</span>
                         <span class="n">SynType</span><span class="p">(</span><span class="s1">&#39;GABA_B&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;purple&#39;</span>  <span class="p">),))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Connection list contains unknown synapse models; synTypes required.&#39;</span><span class="p">)</span>

        <span class="c1"># now build _synAttr by assigning blocks to rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="k">for</span> <span class="n">sgroup</span> <span class="ow">in</span> <span class="n">synTypes</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">stype</span> <span class="ow">in</span> <span class="n">sgroup</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="p">[</span><span class="n">stype</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SynProps</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">stype</span><span class="o">.</span><span class="n">relweight</span><span class="p">,</span> 
                                                           <span class="n">stype</span><span class="o">.</span><span class="n">cmap</span><span class="p">,</span> <span class="n">ctr</span><span class="p">)</span>
                <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">row</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># ----------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lList</span><span class="p">,</span> <span class="n">cList</span><span class="p">,</span> <span class="n">synTypes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">intensity</span><span class="o">=</span><span class="s1">&#39;wp&#39;</span><span class="p">,</span> 
                 <span class="n">mList</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Vmem</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">poporder</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        lList    : layer list</span>
<span class="sd">        cList    : connection list</span>
<span class="sd">        synTypes : nested list of synapse types</span>
<span class="sd">        intensity: &#39;wp&#39;  - weight * probability</span>
<span class="sd">                   &#39;p&#39;   - probability</span>
<span class="sd">                   &#39;tcd&#39; - |total charge deposited| * probability</span>
<span class="sd">                           requires mList; currently only for ht_model</span>
<span class="sd">                           proper results only if Vmem within reversal potentials</span>
<span class="sd">        mList    : model list; only needed with &#39;tcd&#39;</span>
<span class="sd">        Vmem     : reference membrane potential for &#39;tcd&#39;</span>
<span class="sd">        poporder : dictionary mapping population names to numbers; populations</span>
<span class="sd">                   will be sorted in diagram in order of increasing numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># extract layers to dict mapping name to extent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_LayerProps</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;extent&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lList</span><span class="p">]</span> 

        <span class="c1"># ensure layer names are unique</span>
        <span class="n">lnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lnames</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lnames</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Layer names must be unique.&#39;</span><span class="p">)</span>

        <span class="c1"># set up synapse attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_configSynapses</span><span class="p">(</span><span class="n">cList</span><span class="p">,</span> <span class="n">synTypes</span><span class="p">)</span>

        <span class="c1"># if tcd mode, build tcd representation</span>
        <span class="k">if</span> <span class="n">intensity</span> <span class="o">!=</span> <span class="s1">&#39;tcd&#39;</span><span class="p">:</span>
            <span class="n">tcd</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">mList</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">tcd_nest</span>
            <span class="n">tcd</span> <span class="o">=</span> <span class="n">tcd_nest</span><span class="o">.</span><span class="n">TCD</span><span class="p">(</span><span class="n">mList</span><span class="p">)</span>

        <span class="c1"># Build internal representation of connections.</span>
        <span class="c1"># This representation contains one entry for each sender pop, target pop,</span>
        <span class="c1"># synapse type tuple. Creating the connection object implies computation</span>
        <span class="c1"># of the kernel. </span>
        <span class="c1"># Several connection may agree in all properties, these need to be</span>
        <span class="c1"># added here. Therefore, we need to build iteratively and store</span>
        <span class="c1"># everything in a dictionary, so we can find early instances.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">cList</span><span class="p">:</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Connection</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="p">,</span>
                                        <span class="n">intensity</span><span class="p">,</span> <span class="n">tcd</span><span class="p">,</span> <span class="n">Vmem</span><span class="p">)</span><span class="o">.</span><span class="n">keyval</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span>

        <span class="c1"># number of layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nlyr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">)</span>

        <span class="c1"># compile list of populations, list(set()) makes list unique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">_flattened</span><span class="p">([[(</span><span class="n">c</span><span class="o">.</span><span class="n">slayer</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">snrn</span><span class="p">),</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">tlayer</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">tnrn</span><span class="p">)]</span> \
                                             <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="o">.</span><span class="n">values</span><span class="p">())])))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_npop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pops</span><span class="p">)</span>

        <span class="c1"># store population ordering; if not given, use alphabetical ordering</span>
        <span class="c1"># also add any missing populations alphabetically at end</span>
        <span class="c1"># layers are ignored</span>
        <span class="c1"># create alphabetically sorted list of unique population names</span>
        <span class="n">popnames</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pops</span><span class="p">])),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">poporder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_poporder</span> <span class="o">=</span> <span class="n">poporder</span>
            <span class="nb">next</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_poporder</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># next free sorting index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_poporder</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="nb">next</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">pname</span> <span class="ow">in</span> <span class="n">popnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poporder</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_poporder</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span>
                <span class="nb">next</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># compile list of synapse types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synTypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">synmodel</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="o">.</span><span class="n">values</span><span class="p">())]))</span>

    <span class="c1"># ----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="ConnectionPattern.plot"><a class="viewcode-back" href="../../modules/ConnPlotter.html#ConnPlotter.ConnPlotter.ConnectionPattern.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aggrGroups</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">aggrSyns</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">globalColors</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">colorLimits</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">showLegend</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
             <span class="n">selectSyns</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fixedWidth</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot connection pattern.</span>
<span class="sd">        By default, connections between any pair of populations</span>
<span class="sd">        are plotted on the screen, with separate color scales for</span>
<span class="sd">        all patches.</span>

<span class="sd">        Arguments:</span>
<span class="sd">        aggrGroups  If True, aggregate projections with the same synapse type</span>
<span class="sd">                    and the same source and target groups (default: False)</span>

<span class="sd">        aggrSyns    If True, aggregate projections with the same synapse model (default: False)</span>

<span class="sd">        globalColors  If True, use global color scale, otherwise local (default: False)</span>

<span class="sd">        colorLimits   If given, must be two element vector for lower and upper limits of</span>
<span class="sd">                      color scale. Implies globalColors (default: None)</span>

<span class="sd">        showLegend   If True, show legend below CPT (default: True).</span>

<span class="sd">        selectSyns    If tuple of synapse models, show only connections of the </span>
<span class="sd">                      give types. Cannot be combined with aggregation.</span>

<span class="sd">        file     If given, save plot to given file name; file may also be a tuple of </span>
<span class="sd">                 file names, the figure will then be saved to all files. This may be </span>
<span class="sd">                 useful if you want to save the same figure in several formats.</span>
<span class="sd">                 You should not save to PDF directly, this may lead to artefacts; </span>
<span class="sd">                 rather save to PS or EPS, then convert. </span>

<span class="sd">        fixedWidth Figure will be scaled to this width in mm by changing patch size.</span>

<span class="sd">        Returns:</span>
<span class="sd">        kern_min, kern_max   Minimal and maximal values of kernels, with kern_min &lt;=0, kern_max&gt;=0.</span>

<span class="sd">        Output:</span>
<span class="sd">        figure created</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># translate new to old paramter names (per v 0.5)</span>
        <span class="n">normalize</span> <span class="o">=</span> <span class="n">globalColors</span>
        <span class="k">if</span> <span class="n">colorLimits</span><span class="p">:</span>
            <span class="n">normalize</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">selectSyns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">aggrPops</span> <span class="ow">or</span> <span class="n">aggrSyns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;selectSyns cannot be combined with aggregation.&#39;</span><span class="p">)</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="n">selectSyns</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;select&#39;</span>
        <span class="k">elif</span> <span class="n">aggrGroups</span> <span class="ow">and</span> <span class="n">aggrSyns</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;totals&#39;</span>
        <span class="k">elif</span> <span class="n">aggrGroups</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">aggrSyns</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;layer&#39;</span>
        <span class="k">elif</span> <span class="n">aggrSyns</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">aggrGroups</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;population&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;layer&#39;</span><span class="p">:</span>
            <span class="c1"># reduce to dimensions sender layer, target layer, synapse type</span>
            <span class="c1"># add all kernels agreeing on these three attributes</span>
            <span class="n">plotKerns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">slayer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">tlayer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">synmodel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synTypes</span><span class="p">:</span>
                        <span class="n">kerns</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">kernval</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                                 <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">sl</span><span class="o">=</span><span class="n">slayer</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tl</span><span class="o">=</span><span class="n">tlayer</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">syn</span><span class="o">=</span><span class="n">synmodel</span><span class="p">)]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kerns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">plotKerns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_PlotKern</span><span class="p">(</span><span class="n">slayer</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">tlayer</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">synmodel</span><span class="p">,</span> 
                                                            <span class="n">_addKernels</span><span class="p">(</span><span class="n">kerns</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;population&#39;</span><span class="p">:</span>
            <span class="c1"># reduce to dimensions sender layer, target layer</span>
            <span class="c1"># all all kernels, weighting according to synapse type</span>
            <span class="n">plotKerns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">spop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pops</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">tpop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pops</span><span class="p">:</span>
                    <span class="n">kerns</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">synmodel</span><span class="p">]</span><span class="o">.</span><span class="n">tw</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">kernval</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                             <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">sl</span><span class="o">=</span><span class="n">spop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sn</span><span class="o">=</span><span class="n">spop</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tl</span><span class="o">=</span><span class="n">tpop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tn</span><span class="o">=</span><span class="n">tpop</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kerns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">plotKerns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_PlotKern</span><span class="p">(</span><span class="n">spop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spop</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tpop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tpop</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> 
                                                        <span class="n">_addKernels</span><span class="p">(</span><span class="n">kerns</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;totals&#39;</span><span class="p">:</span>
            <span class="c1"># reduce to dimensions sender layer, target layer</span>
            <span class="c1"># all all kernels, weighting according to synapse type</span>
            <span class="n">plotKerns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">slayer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">tlayer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">:</span>
                    <span class="n">kerns</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">synmodel</span><span class="p">]</span><span class="o">.</span><span class="n">tw</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">kernval</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                             <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">sl</span><span class="o">=</span><span class="n">slayer</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tl</span><span class="o">=</span><span class="n">tlayer</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kerns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">plotKerns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_PlotKern</span><span class="p">(</span><span class="n">slayer</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">tlayer</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> 
                                                        <span class="n">_addKernels</span><span class="p">(</span><span class="n">kerns</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;select&#39;</span><span class="p">:</span>
            <span class="c1"># copy only those kernels that have the requested synapse type,</span>
            <span class="c1"># no dimension reduction</span>
            <span class="c1"># nb: we need to sum all kernels in the list for a set of attributes</span>
            <span class="n">plotKerns</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_PlotKern</span><span class="p">(</span><span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">slayer</span><span class="p">,</span> <span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">snrn</span><span class="p">,</span> <span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tlayer</span><span class="p">,</span> <span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tnrn</span><span class="p">,</span> 
                                        <span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">synmodel</span><span class="p">,</span> <span class="n">_addKernels</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">kernval</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clist</span><span class="p">]))</span>
                         <span class="k">for</span> <span class="n">clist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">synmodel</span> <span class="ow">in</span> <span class="n">selected</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># copy all</span>
            <span class="c1"># nb: we need to sum all kernels in the list for a set of attributes</span>
            <span class="n">plotKerns</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_PlotKern</span><span class="p">(</span><span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">slayer</span><span class="p">,</span> <span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">snrn</span><span class="p">,</span> <span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tlayer</span><span class="p">,</span> <span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tnrn</span><span class="p">,</span> 
                                        <span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">synmodel</span><span class="p">,</span> <span class="n">_addKernels</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">kernval</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clist</span><span class="p">]))</span>
                         <span class="k">for</span> <span class="n">clist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepareAxes</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">showLegend</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fixedWidth</span><span class="p">:</span>

            <span class="n">margs</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">margins</span><span class="o">.</span><span class="n">left</span> <span class="o">+</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">margins</span><span class="o">.</span><span class="n">right</span>

            <span class="k">if</span> <span class="n">fixedWidth</span> <span class="o">&lt;=</span> <span class="n">margs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Requested width must be less than width of margins (</span><span class="si">%g</span><span class="s1"> mm)&#39;</span> <span class="o">%</span> <span class="n">margs</span><span class="p">)</span>

            <span class="n">currWidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">lr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">currPatchMax</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">patch_size</span> <span class="c1"># store</span>
            
            <span class="c1"># compute required patch size</span>
            <span class="n">plotParams</span><span class="o">.</span><span class="n">patch_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">fixedWidth</span> <span class="o">-</span> <span class="n">margs</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">currWidth</span> <span class="o">-</span> <span class="n">margs</span><span class="p">)</span> <span class="o">*</span> <span class="n">currPatchMax</span>

            <span class="c1"># build new axes</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prepareAxes</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">showLegend</span><span class="p">)</span>

            <span class="c1"># restore patch size</span>
            <span class="n">plotParams</span><span class="o">.</span><span class="n">patch_size</span> <span class="o">=</span> <span class="n">currPatchMax</span>

        <span class="c1"># create figure with desired size</span>
        <span class="n">fsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">lr</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.4</span> <span class="c1"># convert mm to inches</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">fsize</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="c1"># size will be rounded according to DPI setting, adjust fsize </span>
        <span class="n">dpi</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_dpi</span><span class="p">()</span>
        <span class="n">fsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">fsize</span><span class="o">*</span><span class="n">dpi</span><span class="p">)</span> <span class="o">/</span> <span class="n">dpi</span>

        <span class="c1"># check that we got the correct size</span>
        <span class="n">actsize</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">get_figwidth</span><span class="p">(),</span> <span class="n">f</span><span class="o">.</span><span class="n">get_figheight</span><span class="p">()],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">actsize</span> <span class="o">==</span> <span class="n">fsize</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_figscale</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># no scaling</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                  WARNING: Figure shrunk on screen!</span>
<span class="s2">                  The figure is shrunk to fit onto the screen.</span>

<span class="s2">                  Please specify a different backend using the -d</span>
<span class="s2">                  option to obtain full-size figures. Your current</span>
<span class="s2">                  backend is: </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">                  &quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">mpl</span><span class="o">.</span><span class="n">get_backend</span><span class="p">())</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            
            <span class="c1"># determine scale: most shrunk dimension</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_figscale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">actsize</span> <span class="o">/</span> <span class="n">fsize</span><span class="p">)</span>
            
            <span class="c1"># create shrunk on-screen figure</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_figscale</span><span class="o">*</span><span class="n">fsize</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> 

            <span class="c1"># just ensure all is well now</span>
            <span class="n">actsize</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">get_figwidth</span><span class="p">(),</span> <span class="n">f</span><span class="o">.</span><span class="n">get_figheight</span><span class="p">()],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>


        <span class="c1"># add decoration</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">elements</span><span class="p">):</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scaledBox</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
                            <span class="n">axisbg</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">layer_bg</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">location</span><span class="p">],</span> <span class="n">xticks</span><span class="o">=</span><span class="p">[],</span> <span class="n">yticks</span><span class="o">=</span><span class="p">[],</span>
                            <span class="n">zorder</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">z_layer</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">sp</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>  <span class="c1"># turn off axis lines, make room for frame edge</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">l_patches</span> <span class="ow">and</span> <span class="n">block</span><span class="o">.</span><span class="n">slbl</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">slbl</span><span class="p">,</span> 
                              <span class="n">rotation</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">layer_orientation</span><span class="p">[</span><span class="s1">&#39;sender&#39;</span><span class="p">],</span>
                              <span class="n">fontproperties</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">layer_font</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">t_patches</span> <span class="ow">and</span> <span class="n">block</span><span class="o">.</span><span class="n">tlbl</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">tlbl</span><span class="p">,</span> 
                              <span class="n">rotation</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">layer_orientation</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">],</span>
                              <span class="n">fontproperties</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">layer_font</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_label_position</span><span class="p">(</span><span class="s1">&#39;top&#39;</span><span class="p">)</span>

            <span class="c1"># inner blocks for population labels</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;totals&#39;</span><span class="p">,</span> <span class="s1">&#39;layer&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">pb</span> <span class="ow">in</span> <span class="n">_flattened</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">elements</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Block</span><span class="p">):</span>
                        <span class="k">continue</span> <span class="c1"># should not happen</span>

                    <span class="n">ax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scaledBox</span><span class="p">(</span><span class="n">pb</span><span class="p">),</span>
                                    <span class="n">axisbg</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">xticks</span><span class="o">=</span><span class="p">[],</span> <span class="n">yticks</span><span class="o">=</span><span class="p">[],</span> 
                                    <span class="n">zorder</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">z_pop</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">):</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                            <span class="n">sp</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>  <span class="c1"># turn off axis lines, make room for frame edge</span>
                    <span class="k">if</span> <span class="n">pb</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="n">pb</span><span class="o">.</span><span class="n">w</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">r_patches</span> <span class="ow">and</span> <span class="n">pb</span><span class="o">.</span><span class="n">slbl</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">pb</span><span class="o">.</span><span class="n">slbl</span><span class="p">,</span> 
                                      <span class="n">rotation</span><span class="o">=</span><span class="n">plotParams</span><span class="o">.</span><span class="n">pop_orientation</span><span class="p">[</span><span class="s1">&#39;sender&#39;</span><span class="p">],</span>
                                      <span class="n">fontproperties</span><span class="o">=</span><span class="n">plotParams</span><span class="o">.</span><span class="n">pop_font</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_position</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pb</span><span class="o">.</span><span class="n">t</span><span class="o">+</span><span class="n">pb</span><span class="o">.</span><span class="n">h</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="o">.</span><span class="n">b_patches</span> <span class="ow">and</span> <span class="n">pb</span><span class="o">.</span><span class="n">tlbl</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">pb</span><span class="o">.</span><span class="n">tlbl</span><span class="p">,</span> 
                                      <span class="n">rotation</span><span class="o">=</span><span class="n">plotParams</span><span class="o">.</span><span class="n">pop_orientation</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">],</span>
                                      <span class="n">fontproperties</span><span class="o">=</span><span class="n">plotParams</span><span class="o">.</span><span class="n">pop_font</span><span class="p">)</span>

        <span class="c1"># determine minimum and maximum values across all kernels, but set min &lt;= 0, max &gt;= 0</span>
        <span class="n">kern_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">kern</span><span class="o">.</span><span class="n">kern</span><span class="p">)</span> <span class="k">for</span> <span class="n">kern</span> <span class="ow">in</span> <span class="n">plotKerns</span><span class="p">]))</span>
        <span class="n">kern_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">kern</span><span class="o">.</span><span class="n">kern</span><span class="p">)</span> <span class="k">for</span> <span class="n">kern</span> <span class="ow">in</span> <span class="n">plotKerns</span><span class="p">]))</span>

        <span class="c1"># determine color limits for plots</span>
        <span class="k">if</span> <span class="n">colorLimits</span><span class="p">:</span>
            <span class="n">c_min</span><span class="p">,</span> <span class="n">c_max</span> <span class="o">=</span> <span class="n">colorLimits</span>  <span class="c1"># explicit values</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># default values for color limits</span>
            <span class="c1"># always 0 as lower limit so anything &gt; 0 is non-white, except when totals or populations</span>
            <span class="n">c_min</span> <span class="o">=</span> <span class="bp">None</span> <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;totals&#39;</span><span class="p">,</span><span class="s1">&#39;population&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.0</span>
            <span class="n">c_max</span> <span class="o">=</span> <span class="bp">None</span>   <span class="c1"># use patch maximum as upper limit</span>
            
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="c1"># use overall maximum, at least 0</span>
                <span class="n">c_max</span> <span class="o">=</span> <span class="n">kern_max</span>
                <span class="k">if</span> <span class="n">aggrSyns</span><span class="p">:</span>
                    <span class="c1"># use overall minimum, if negative, otherwise 0</span>
                    <span class="n">c_min</span> <span class="o">=</span> <span class="n">kern_min</span>
                    <span class="c1"># for c_max, use the larger of the two absolute values</span>
                    <span class="n">c_max</span> <span class="o">=</span> <span class="n">kern_max</span>
                    <span class="c1"># if c_min is non-zero, use same color scale for neg values</span>
                    <span class="k">if</span> <span class="n">c_min</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">c_min</span> <span class="o">=</span> <span class="o">-</span><span class="n">c_max</span>

        <span class="c1"># Initialize dict storing sample patches for each synapse type for use</span>
        <span class="c1"># in creating color bars. We will store the last patch of any given </span>
        <span class="c1"># synapse type for reference. When aggrSyns, we have only one patch type</span>
        <span class="c1"># and store that.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">aggrSyns</span><span class="p">:</span>
            <span class="n">samplePatches</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">sname</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">sname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># only single type of patches</span>
            <span class="n">samplePatches</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">for</span> <span class="n">kern</span> <span class="ow">in</span> <span class="n">plotKerns</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patchTable</span><span class="p">[(</span><span class="n">kern</span><span class="o">.</span><span class="n">sl</span><span class="p">,</span><span class="n">kern</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span><span class="n">kern</span><span class="o">.</span><span class="n">tl</span><span class="p">,</span><span class="n">kern</span><span class="o">.</span><span class="n">tn</span><span class="p">,</span><span class="n">kern</span><span class="o">.</span><span class="n">syn</span><span class="p">)]</span>
            
            <span class="n">p</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scaledBox</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> 
                              <span class="n">xticks</span><span class="o">=</span><span class="p">[],</span> <span class="n">yticks</span><span class="o">=</span><span class="p">[],</span> <span class="n">zorder</span><span class="o">=</span><span class="n">plotParams</span><span class="o">.</span><span class="n">z_conn</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ax</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">):</span>
                <span class="n">p</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">sp</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>  <span class="c1"># turn off axis lines, make room for frame edge</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">aggrSyns</span><span class="p">:</span>
                <span class="c1"># we have synapse information -&gt; not totals, a vals positive</span>
                <span class="k">assert</span><span class="p">(</span><span class="n">kern</span><span class="o">.</span><span class="n">syn</span><span class="p">)</span>
                <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">kern</span><span class="o">.</span><span class="n">kern</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span>

                <span class="c1"># we may overwrite here, but this does not matter, we only need </span>
                <span class="c1"># some reference patch</span>
                <span class="n">samplePatches</span><span class="p">[</span><span class="n">kern</span><span class="o">.</span><span class="n">syn</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">kern</span><span class="o">.</span><span class="n">kern</span><span class="p">,</span> 
                                                      <span class="n">vmin</span> <span class="o">=</span> <span class="n">c_min</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">c_max</span><span class="p">,</span>
                                                      <span class="n">cmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="p">[</span><span class="n">kern</span><span class="o">.</span><span class="n">syn</span><span class="p">]</span><span class="o">.</span><span class="n">cmap</span><span class="p">)</span><span class="c1">#,</span>
                                  <span class="c1"># interpolation=&#39;nearest&#39;)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we have totals, special color table and normalization</span>

                <span class="c1"># we may overwrite here, but this does not matter, we only need </span>
                <span class="c1"># some reference patch</span>
                <span class="n">samplePatches</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">kern</span><span class="o">.</span><span class="n">kern</span><span class="p">,</span> 
                                  <span class="n">vmin</span> <span class="o">=</span> <span class="n">c_min</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">c_max</span><span class="p">,</span>
                                  <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">bluered</span><span class="p">,</span>
                                  <span class="n">norm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ZeroCenterNorm</span><span class="p">())</span> <span class="c1">#, # must be instance</span>
                                  <span class="c1"># interpolation=&#39;nearest&#39;)</span>

        <span class="c1"># Create colorbars at bottom of figure</span>
        <span class="k">if</span> <span class="n">showLegend</span><span class="p">:</span>

            <span class="c1"># FIXME: rewrite the function to avoid comparisons with None!</span>
            <span class="n">f_min</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">c_min</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">c_min</span>
            <span class="n">f_max</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">c_max</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">c_max</span>

            <span class="c1"># Do we have kernel values exceeding the color limits?</span>
            <span class="k">if</span> <span class="n">f_min</span> <span class="o">&lt;=</span> <span class="n">kern_min</span> <span class="ow">and</span> <span class="n">kern_max</span> <span class="o">&lt;=</span> <span class="n">f_max</span><span class="p">:</span>
                <span class="n">extmode</span> <span class="o">=</span> <span class="s1">&#39;neither&#39;</span>
            <span class="k">elif</span> <span class="n">f_min</span> <span class="o">&gt;</span> <span class="n">kern_min</span> <span class="ow">and</span> <span class="n">kern_max</span> <span class="o">&lt;=</span> <span class="n">f_max</span><span class="p">:</span>
                <span class="n">extmode</span> <span class="o">=</span> <span class="s1">&#39;min&#39;</span>
            <span class="k">elif</span> <span class="n">f_min</span> <span class="o">&lt;=</span> <span class="n">kern_min</span> <span class="ow">and</span> <span class="n">kern_max</span> <span class="o">&gt;</span> <span class="n">f_max</span><span class="p">:</span>
                <span class="n">extmode</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extmode</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>

            <span class="k">if</span> <span class="n">aggrSyns</span><span class="p">:</span>
                <span class="n">cbax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scaledBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbPatches</span><span class="p">))</span>

                <span class="c1"># by default, use 4 ticks to avoid clogging</span>
                <span class="c1"># according to docu, we need a separate Locator object</span>
                <span class="c1"># for each axis.</span>
                <span class="k">if</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">legend_ticks</span><span class="p">:</span>
                    <span class="n">tcks</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">legend_ticks</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tcks</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                    <span class="c1"># colorbar with freely settable ticks</span>
                    <span class="n">cb</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">samplePatches</span><span class="p">,</span> <span class="n">cax</span> <span class="o">=</span> <span class="n">cbax</span><span class="p">,</span>
                                    <span class="n">orientation</span> <span class="o">=</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">,</span>
                                    <span class="n">ticks</span> <span class="o">=</span> <span class="n">tcks</span><span class="p">,</span>
                                    <span class="n">format</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">legend_tick_format</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="n">extmode</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># colorbar with tick labels &#39;Exc&#39;, &#39;Inh&#39;</span>
                    <span class="c1"># we add the color bare here explicitly, so we get no problems</span>
                    <span class="c1"># if the sample patch includes only pos or only neg values</span>
                    <span class="n">cb</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colorbar</span><span class="o">.</span><span class="n">ColorbarBase</span><span class="p">(</span><span class="n">cbax</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">bluered</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">)</span>
                    <span class="n">cbax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">cbax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="s1">&#39;Inh&#39;</span><span class="p">,</span> <span class="s1">&#39;Exc&#39;</span><span class="p">])</span>

                <span class="n">cb</span><span class="o">.</span><span class="n">outline</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># narrower line around colorbar</span>

                <span class="c1"># fix font for ticks</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">cbax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">fontproperties</span><span class="o">=</span><span class="n">plotParams</span><span class="o">.</span><span class="n">legend_tick_font</span><span class="p">)</span>

                <span class="c1"># no title in this case</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># loop over synapse types</span>
                <span class="k">for</span> <span class="n">syn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">cbax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scaledBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbPatches</span><span class="p">[</span><span class="n">syn</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">legend_location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">cbax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">syn</span><span class="p">,</span> <span class="n">fontproperties</span><span class="o">=</span><span class="n">plotParams</span><span class="o">.</span><span class="n">legend_title_font</span><span class="p">,</span>
                                        <span class="n">rotation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cbax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">syn</span><span class="p">,</span> <span class="n">fontproperties</span><span class="o">=</span><span class="n">plotParams</span><span class="o">.</span><span class="n">legend_title_font</span><span class="p">,</span>
                                       <span class="n">rotation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>

                        <span class="c1"># by default, use 4 ticks to avoid clogging</span>
                        <span class="c1"># according to docu, we need a separate Locator object</span>
                        <span class="c1"># for each axis.</span>
                        <span class="k">if</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">legend_ticks</span><span class="p">:</span>
                            <span class="n">tcks</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">legend_ticks</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">tcks</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

                        <span class="c1"># proper colorbar</span>
                        <span class="n">cb</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">samplePatches</span><span class="p">[</span><span class="n">syn</span><span class="p">],</span> <span class="n">cax</span> <span class="o">=</span> <span class="n">cbax</span><span class="p">,</span>                               
                                        <span class="n">orientation</span> <span class="o">=</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">,</span>
                                        <span class="n">ticks</span> <span class="o">=</span> <span class="n">tcks</span><span class="p">,</span>
                                        <span class="n">format</span> <span class="o">=</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">legend_tick_format</span><span class="p">,</span>
                                        <span class="n">extend</span> <span class="o">=</span> <span class="n">extmode</span><span class="p">)</span>
                        <span class="n">cb</span><span class="o">.</span><span class="n">outline</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># narrower line around colorbar</span>

                        <span class="c1"># fix font for ticks</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">cbax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> 
                                 <span class="n">fontproperties</span><span class="o">=</span><span class="n">plotParams</span><span class="o">.</span><span class="n">legend_tick_font</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># just a solid color bar with no ticks</span>
                        <span class="n">cbax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
                        <span class="n">cbax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

                        <span class="c1"># full-intensity color from color map</span>
                        <span class="n">cbax</span><span class="o">.</span><span class="n">set_axis_bgcolor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_synAttr</span><span class="p">[</span><span class="n">syn</span><span class="p">]</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>

                        <span class="c1"># narrower border</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cbax</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">):</span>
                            <span class="n">cbax</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">cbax</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                                <span class="n">sp</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># save to file(s), use full size</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="n">fsize</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="nb">file</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="n">actsize</span><span class="p">)</span>  <span class="c1"># reset size for further interactive work</span>

        <span class="k">return</span> <span class="n">kern_min</span><span class="p">,</span> <span class="n">kern_max</span></div>

    <span class="c1"># ----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="ConnectionPattern.toLaTeX"><a class="viewcode-back" href="../../modules/ConnPlotter.html#ConnPlotter.ConnPlotter.ConnectionPattern.toLaTeX">[docs]</a>    <span class="k">def</span> <span class="nf">toLaTeX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span> <span class="n">standalone</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="nb">enumerate</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">legend</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write connection table to file.</span>

<span class="sd">        Arguments:</span>
<span class="sd">        file        output file name</span>
<span class="sd">        standalone  create complete LaTeX file (default: False)</span>
<span class="sd">        enumerate   enumerate connections (default: False)</span>
<span class="sd">        legend      add explanation of functions used (default: True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lfile</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Could not open file &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="nb">file</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">standalone</span><span class="p">:</span>
            <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>\
<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">\documentclass[a4paper,american]{article}</span>
<span class="sd">\usepackage[pdftex,margin=1in,centering,noheadfoot,a4paper]{geometry}</span>
<span class="sd">\usepackage[T1]{fontenc}</span>
<span class="sd">\usepackage[utf8]{inputenc}</span>
<span class="sd">	</span>
<span class="sd">\usepackage{color}</span>
<span class="sd">\usepackage{calc}</span>
<span class="sd">\usepackage{tabularx}  % automatically adjusts column width in tables</span>
<span class="sd">\usepackage{multirow}  % allows entries spanning several rows  </span>
<span class="sd">\usepackage{colortbl}  % allows coloring tables</span>
<span class="sd">\usepackage[fleqn]{amsmath}</span>
<span class="sd">\setlength{\mathindent}{0em}</span>

<span class="sd">\usepackage{mathpazo}</span>
<span class="sd">\usepackage[scaled=.95]{helvet}</span>
<span class="sd">\renewcommand\familydefault{\sfdefault}</span>

<span class="sd">\renewcommand\arraystretch{1.2}</span>
<span class="sd">\pagestyle{empty}</span>

<span class="sd">% \hdr{ncols}{label}{title}</span>
<span class="sd">%</span>
<span class="sd">% Typeset header bar across table with ncols columns </span>
<span class="sd">% with label at left margin and centered title</span>
<span class="sd">%</span>
<span class="sd">\newcommand{\hdr}[3]{%</span>
<span class="sd">  \multicolumn{#1}{|l|}{%</span>
<span class="sd">    \color{white}\cellcolor[gray]{0.0}%</span>
<span class="sd">    \textbf{\makebox[0pt]{#2}\hspace{0.5\linewidth}\makebox[0pt][c]{#3}}%</span>
<span class="sd">  }%</span>
<span class="sd">}</span>

<span class="sd">\begin{document}</span>
<span class="sd">&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>\
<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">\noindent\begin{tabularx}{\linewidth}{%s|l|l|l|c|c|X|}\hline</span>
<span class="sd">\hdr{%d}{}{Connectivity}\\\hline</span>
<span class="sd">%s \textbf{Src} &amp; \textbf{Tgt} &amp; \textbf{Syn} &amp;</span>
<span class="sd">\textbf{Wght} &amp; \textbf{Mask} &amp; \textbf{Kernel} \\\hline</span>
<span class="sd">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">((</span><span class="s1">&#39;|r&#39;</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">enumerate</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)))</span>
        <span class="c1"># ensure sorting according to keys, gives some alphabetic sorting</span>
        <span class="n">haveU</span><span class="p">,</span> <span class="n">haveG</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span>

        <span class="n">cctr</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># connection counter</span>
        <span class="k">for</span> <span class="n">ckey</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cTable</span><span class="p">[</span><span class="n">ckey</span><span class="p">]:</span>

                <span class="n">cctr</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">enumerate</span><span class="p">:</span> <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> &amp;&#39;</span> <span class="o">%</span> <span class="n">cctr</span><span class="p">)</span>

                <span class="c1"># take care to escape _ in names such as GABA_A</span>
                <span class="c1"># also remove any pending &#39;/None&#39;</span>
                <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="s1">r&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1"> &amp; </span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1"> &amp; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> \
                                 <span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">slayer</span><span class="p">,</span> <span class="n">conn</span><span class="o">.</span><span class="n">snrn</span><span class="p">,</span> <span class="n">conn</span><span class="o">.</span><span class="n">tlayer</span><span class="p">,</span> <span class="n">conn</span><span class="o">.</span><span class="n">tnrn</span><span class="p">,</span>
                                  <span class="n">conn</span><span class="o">.</span><span class="n">synmodel</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">r&#39;\_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/None&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">))</span>
                <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &amp; </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">float</span><span class="p">)):</span>
                    <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">conn</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s1">&#39;uniform&#39;</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">weight</span><span class="p">:</span>
                    <span class="n">cw</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">]</span>
                    <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;$\mathcal{U}[</span><span class="si">%g</span><span class="s1">, </span><span class="si">%g</span><span class="s1">)$&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cw</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">],</span> <span class="n">cw</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]))</span>
                    <span class="n">haveU</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unkown weight type &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">conn</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">__str__</span><span class="p">)</span>
                <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &amp; </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="s1">&#39;circular&#39;</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
                    <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;$\leq </span><span class="si">%g</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="n">conn</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="s1">&#39;circular&#39;</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span>
                <span class="k">elif</span> <span class="s1">&#39;rectangular&#39;</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
                    <span class="n">cmr</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="s1">&#39;rectangular&#39;</span><span class="p">]</span>
                    <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>\
                        <span class="sd">r&quot;&quot;&quot;$[(%+g, %+g), (%+g, %+g)]$&quot;&quot;&quot;</span> \
                            <span class="o">%</span> <span class="p">(</span><span class="n">cmr</span><span class="p">[</span><span class="s1">&#39;lower_left&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmr</span><span class="p">[</span><span class="s1">&#39;lower_left&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">cmr</span><span class="p">[</span><span class="s1">&#39;upper_right&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmr</span><span class="p">[</span><span class="s1">&#39;upper_right&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown mask type &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">conn</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">__str__</span><span class="p">)</span>
                <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &amp; </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                    <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;$</span><span class="si">%g</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="n">conn</span><span class="o">.</span><span class="n">kernel</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s1">&#39;gaussian&#39;</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">kernel</span><span class="p">:</span>
                    <span class="n">ckg</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">kernel</span><span class="p">[</span><span class="s1">&#39;gaussian&#39;</span><span class="p">]</span>
                    <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;$\mathcal{G}(p_0 = </span><span class="si">%g</span><span class="s1">, \sigma = </span><span class="si">%g</span><span class="s1">)$&#39;</span> <span class="o">%</span> \
                                    <span class="p">(</span><span class="n">ckg</span><span class="p">[</span><span class="s1">&#39;p_center&#39;</span><span class="p">],</span> <span class="n">ckg</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]))</span>
                    <span class="n">haveG</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unkown kernel type &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">conn</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">__str__</span><span class="p">)</span>
                <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;</span><span class="se">\\</span><span class="s1">\hline&#39;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">legend</span> <span class="ow">and</span> <span class="p">(</span><span class="n">haveU</span> <span class="ow">or</span> <span class="n">haveG</span><span class="p">):</span>
            <span class="c1"># add bottom line with legend</span>
            <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;\hline&#39;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;\multicolumn{</span><span class="si">%d</span><span class="s1">}{|l|}{\footnotesize &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">7</span> <span class="k">if</span> <span class="nb">enumerate</span> <span class="k">else</span> <span class="mi">6</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">haveG</span><span class="p">:</span>
                <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;$\mathcal{G}(p_0, \sigma)$: $p(\mathbf{x})=p_0 e^{-\mathbf{x}^2/2\sigma^2}$&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">haveG</span> <span class="ow">and</span> <span class="n">haveU</span><span class="p">:</span>
                <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;, &#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">haveU</span><span class="p">:</span>
                <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;$\mathcal{U}[a, b)$: uniform distribution on $[a, b)$&#39;</span><span class="p">)</span>
            <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;}</span><span class="se">\\</span><span class="s1">\hline&#39;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;\end{tabularx}&#39;</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">standalone</span><span class="p">:</span>
            <span class="n">lfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">r&#39;\end{document}&#39;&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">lfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div></div>
        
<span class="c1"># ----------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">_evalkernel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">intensity</span><span class="p">,</span> <span class="n">tcd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot kernel within extent. </span>
<span class="sd">    </span>
<span class="sd">    Kernel values are multiplied with abs(weight). If weight is a </span>
<span class="sd">    distribution, the mean value is used.</span>
<span class="sd">    </span>
<span class="sd">    Result is a masked array, in which the values outside the mask are </span>
<span class="sd">    masked.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># determine resolution, number of data points</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span> <span class="o">/</span> <span class="n">plotParams</span><span class="o">.</span><span class="n">n_kern</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">dx</span><span class="p">)</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">dx</span><span class="p">)</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nx</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ny</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">intensity</span> <span class="o">==</span> <span class="s1">&#39;wp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">*</span> <span class="n">_kerneval</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">kernel</span><span class="p">),</span> 
                                  <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_maskeval</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">mask</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">intensity</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">_kerneval</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">kernel</span><span class="p">),</span> 
                                  <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_maskeval</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">mask</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">intensity</span> <span class="o">==</span> <span class="s1">&#39;tcd&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">tcd</span><span class="p">)</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">*</span> <span class="n">_kerneval</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">kernel</span><span class="p">),</span> 
                                  <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_maskeval</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">mask</span><span class="p">)))</span>


<span class="c1"># ----------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">_weighteval</span><span class="p">(</span><span class="n">weight</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns weight, or mean of distribution, signed.&quot;&quot;&quot;</span>
            
    <span class="n">w</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">weight</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;uniform&#39;</span> <span class="ow">in</span> <span class="n">weight</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">][</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> 
                       <span class="o">+</span> <span class="n">weight</span><span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">][</span><span class="s1">&#39;max&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="s1">&#39;gaussian&#39;</span> <span class="ow">in</span> <span class="n">weight</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="s1">&#39;gaussian&#39;</span><span class="p">][</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown weight type &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">w</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Cannot handle weight.&#39;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

<span class="c1"># ----------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">_maskeval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate mask given as topology style dict at</span>
<span class="sd">    (x,y). Assume x,y are 2d numpy matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;circular&#39;</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="s1">&#39;circular&#39;</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="s1">&#39;doughnut&#39;</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">ri</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="s1">&#39;doughnut&#39;</span><span class="p">][</span><span class="s1">&#39;inner_radius&#39;</span><span class="p">]</span>
        <span class="n">ro</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="s1">&#39;doughnut&#39;</span><span class="p">][</span><span class="s1">&#39;outer_radius&#39;</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ri</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">ro</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s1">&#39;rectangular&#39;</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="s1">&#39;rectangular&#39;</span><span class="p">][</span><span class="s1">&#39;lower_left&#39;</span><span class="p">]</span>        
        <span class="n">ur</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="s1">&#39;rectangular&#39;</span><span class="p">][</span><span class="s1">&#39;upper_right&#39;</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ll</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">ur</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ll</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">ur</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown mask type &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">m</span>

<span class="c1"># ----------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">_kerneval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fun</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate function given as topology style dict at</span>
<span class="sd">    (x,y). Assume x,y are 2d numpy matrices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="s1">&#39;gaussian&#39;</span> <span class="ow">in</span> <span class="n">fun</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">fun</span><span class="p">[</span><span class="s1">&#39;gaussian&#39;</span><span class="p">]</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;p_center&#39;</span><span class="p">]</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">p0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">sig</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown kernel &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fun</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># something very wrong</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Cannot handle kernel.&#39;</span><span class="p">)</span>

<span class="c1"># ----------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">_addKernels</span><span class="p">(</span><span class="n">kList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a list of kernels.</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">    kList:  List of masked arrays of equal size.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    Masked array of same size as input. All values are added,</span>
<span class="sd">    setting masked values to 0. The mask for the sum is the </span>
<span class="sd">    logical AND of all individual masks, so that only such</span>
<span class="sd">    values are masked that are masked in all kernels.</span>
<span class="sd">    _addKernels always returns a new array object, even if</span>
<span class="sd">    kList has only a single element.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">kList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">kList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kList</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">d</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">m</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    
<span class="c1"># ----------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">_flattened</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returned list flattend at first level.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="p">[])</span>

<span class="c1"># ----------------------------------------------------------------------------</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">if __name__ == &quot;__main__&quot;:</span>

<span class="sd">    import sys</span>
<span class="sd">    sys.path += [&#39;./examples&#39;]</span>

<span class="sd">#    import simple</span>
<span class="sd">#    reload(simple)</span>
<span class="sd">    cp = ConnectionPattern(simple.layerList, simple.connectList)</span>

<span class="sd">    import simple2</span>
<span class="sd">    reload(simple2)</span>
<span class="sd">    cp2 = ConnectionPattern(simple2.layerList, simple2.connectList)</span>

<span class="sd">    st3 = ((SynType(&#39;GABA_B&#39;, -5.0, &#39;orange&#39;),</span>
<span class="sd">            SynType(&#39;GABA_A&#39;, -1.0, &#39;m&#39;)),</span>
<span class="sd">           (SynType(&#39;NMDA&#39;, 5.0, &#39;b&#39;),</span>
<span class="sd">            SynType(&#39;FOO&#39;, 1.0, &#39;aqua&#39;),</span>
<span class="sd">            SynType(&#39;AMPA&#39;, 3.0, &#39;g&#39;)))</span>
<span class="sd">    cp3s = ConnectionPattern(simple2.layerList, simple2.connectList,</span>
<span class="sd">                             synTypes=st3)       </span>


<span class="sd">    import simple3</span>
<span class="sd">    reload(simple3)</span>
<span class="sd">    cp3 = ConnectionPattern(simple3.layerList, simple3.connectList)</span>

<span class="sd">    </span>
<span class="sd">#    cp._prepareAxes(&#39;by layer&#39;)</span>
<span class="sd">#    cp2._prepareAxes(&#39;by layer&#39;)</span>
<span class="sd">#    cp3._prepareAxes(&#39;detailed&#39;)</span>

<span class="sd">    cp2.plot()</span>
<span class="sd">    cp2.plot(mode=&#39;layer&#39;)</span>
<span class="sd">    cp2.plot(mode=&#39;population&#39;)</span>
<span class="sd">    cp2.plot(mode=&#39;totals&#39;)</span>
<span class="sd">    cp2.plot(mode=(&#39;AMPA&#39;,))</span>
<span class="sd">    cp2.plot(mode=(&#39;AMPA&#39;,&#39;GABA_B&#39;))</span>
<span class="sd">#    cp3.plot()</span>
<span class="sd">#    cp3.plot(mode=&#39;population&#39;)</span>
<span class="sd">#    cp3.plot(mode=&#39;layer&#39;)</span>
<span class="sd">#    cp3.plot(mode=&#39;totals&#39;)</span>
<span class="sd">#    cp.plot(normalize=True)</span>
<span class="sd">#    cp.plot(totals=True, normalize=True)</span>
<span class="sd">#    cp2.plot()</span>
<span class="sd">#    cp2.plot(file=(&#39;cp3.eps&#39;))</span>
<span class="sd">#    cp2.plot(byLayer=True)</span>
<span class="sd">#    cp2.plot(totals=True)</span>

<span class="sd">&quot;&quot;&quot;</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Nest Initiative.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'2.10.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>